A = [64, 25, 12, 22, 11]

for i in range(len(A)):
    min_idx = i
    for j in range(i + 1, len(A)):
        if A[min_idx] > A[j]:
            min_idx = j

    A[i], A[min_idx] = A[min_idx], A[i]

print("排序后的数组:")
for i in range(len(A)):
    print("%d" % A[i])
#自己操作不正确，通过coplit修改

'''
这段代码实现了选择排序算法。选择排序是一种简单直观的排序算法，它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。

在这段代码中，首先定义了一个列表 `A`，然后通过两层循环来实现选择排序。外层循环 `for i in range(len(A)):` 用于控制遍历的次数，每次遍历都会找出剩余未排序元素中的最小元素。内层循环 `for j in range(i + 1, len(A)):` 用于在每次遍历中，找出从第 `i+1` 个元素到最后一个元素中的最小元素。

在内层循环中，如果找到的元素 `A[j]` 小于当前最小元素 `A[min_idx]`，则更新最小元素的索引 `min_idx`。这样，每一次内层循环结束后，都能找到剩余未排序元素中的最小元素。

然后，通过 `A[i], A[min_idx] = A[min_idx], A[i]` 将找到的最小元素和第 `i` 个元素交换，这样就保证了前 `i` 个元素都是已经排序好的。

最后，通过 `print` 函数打印出排序后的数组。需要注意的是，这个函数没有返回值，因为它直接修改了输入的数组 `A`，即所谓的“原地排序”。'''